#!/usr/bin/env python3

# ---------------------------------------------------------------------
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

# Original Author: Raheman Vaiya
# ---------------------------------------------------------------------

# cfg.opts should consist of lines of the following form:
#
# <option/field name> <type (must be string, int, or double)> <default val>

import sys
import re
import glob
import os

h_template = '''//GENERATED BY %s.

#ifndef _CFG_H_
#define _CFG_H_

struct cfg {
{struct_fields}
};

struct cfg* parse_cfg(const char *fname);

#endif
''' % sys.argv[0]

c_template = r'''//GENERATED BY {script}

#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <stdlib.h>
#include "{header_file}"

static int kvp(char *line, char **key, char **val) {
  *key = NULL;
  *val = NULL;
  
  for(;*line != '\0';line++) {
    if(*line != ' ' && !*key)
      *key = line;
    
    if(*line == ':' && !*val) {
      *line++ = '\0';
      for(;isspace(*line);line++);
      *val = line;
    }
  }
  
  if(*(line - 1) == '\n')
    *(line - 1) = '\0';
  
  if(!(*val && *key))
    return -1;
  
  return 0;
}

struct cfg* parse_cfg(const char *fname) {
    char *line = NULL;
    size_t n = 0, ln = 0;
    struct cfg *cfg = malloc(sizeof(struct cfg));

{field_init}

    FILE *fp = fopen(fname, "r");
    if(!fp) return cfg; //Return defaults if no config file xists..
    while(getline(&line, &n, fp) != -1) {
        ln++;
        char *key, *val;
        if(kvp(line, &key, &val)) {
            fprintf(stderr, "Invalid entry in %s at line %lu.\n", fname, ln);
            exit(1);
        }

{field_checks}

        free(line);
        line = NULL;
        n = 0;
    }

    return cfg;
}
'''.replace('{script}', sys.argv[0])


conversion_map = {
    'string': 'strdup',
    'int': 'atoi',
    'double': 'atof',
}


def generate_h(options):
    struct_fields = ''
    for fld, typ, _, _ in options:
        struct_fields += '    %s %s;\n' % ('char*' if typ ==
                                           'string' else typ, fld)

    return h_template.replace('{struct_fields}', struct_fields.rstrip())


def generate_c(options, header_file):
    field_init = ''
    for fld, typ, default, _ in options:
        field_init += '    cfg->%s = %s;\n' % (
            fld, ('"%s"' % default) if typ == "string" else default)

    field_checks = ''

    cond = 'if'
    for fld, typ, _, _ in options:
        field_checks += '''\
        %s(!strcmp(key, "%s"))
            cfg->%s = %s(val);\n''' % (cond, fld, fld, conversion_map[typ])
        cond = 'else if'

    return c_template\
        .replace('{field_checks}', field_checks.rstrip())\
        .replace('{field_init}', field_init.rstrip())\
        .replace('{header_file}', header_file)


def parse_line(l):
    m = re.match('^(\S*) +(\S*) +"([^"]*)" +"([^"]*)"$', l)
    if not m:
        m = re.match('^(\S*) +(\S*) +(\S*) +"([^"]*)"$', l)

    return m[1], m[2], m[3], m[4]


def read_opts(fname):
    ln = 0
    opts = []
    for l in open(fname, 'r').read().rstrip().split('\n'):
        ln += 1
        if l == '':
            continue

        opts.append(parse_line(l))

    return opts


opts = read_opts('cfg.opts')
header = generate_h(opts)
c = generate_c(opts, 'cfg.h')

optstr = ''
for name, _, val, desc in opts:
    optstr += '**%s**: %s (default: %s).\n\n' % (name, desc, val)

print("Generating README.md")
open('README.md', 'w').write(
    open('README.md.t', 'r').read().replace('{opts}', optstr))
print("man.md")
open('man.md', 'w').write(
    open('man.md.t', 'r').read().replace('{opts}', optstr))
print("Generating src/cfg.c")
open('src/cfg.c', 'w').write(c)
print("Generating src/cfg.h")
open('src/cfg.h', 'w').write(header)
